https://www.weave.works/blog/kubernetes-beginners-guide/
##########################################################################
###################(Dockerfile sample and tutorial site)####################
##########################################################################
FROM node:4.6
WORKDIR /app
ADD ./app
RUN npm install
EXPOSE 3000
CMD npm start
https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images
https://github.com/iraj-norouzi/DockerCheatSheet

docker run -p 3000:3000 -t 


##########################################################################
####################################(POD)###################################
##########################################################################
apiVersion: v1
kind: Pod
metadata:
  name: web-server
  labels:
    app: helloworld
spec:
  containers:
  - name: nginx-igap
    image: nginx
    ports:
    - name: nginx-port
      containerPort: 80


kubernetes cheat sheet 
https://kubernetes.io/docs/reference/kubectl/cheatsheet/

k create -f   first-app/helloworld.yml
kubectl port-forward nodehelloworld.example.com  81:80
curl localhost:81

kubectl expose pod web-server --type=NodePort --name web-server-service

##########################################################################
####################################(UsefulCommand)#######################
##########################################################################
kubectl attach web-server -i
kubectl exec pod -- ls /
kubectl run -i --tty busybox --image=busybox -- sh  # Run pod as interactive shell
kubectl describe {pod,service,node,...}  
kubectl get rc    #display replication controller

##########################################################################
####################################(Replication Controller)##############
##########################################################################
if your application is stateless you can horizontally scale it (scale out)
stateless=your application does not have a state, it doesnot write any local file / keeps local sessions
all traditional databases (mysql,postgres) are stateful , they have database files that can't be split over multiple instance(scale up)
Deployments are a newer and higher level concept than Replication Controllers. They manage the deployment of Replica Sets 
(also a newer concept, but pretty much equivalent to Replication Controllers), and allow for easy updating of a Replica Set as well
as the ability to roll back to a previous deployment.
Previously this would have to be done with kubectl rolling-update which was not declarative and did not provide the rollback features.


apiVersion: v1
kind: ReplicationController
metadata:
  name: helloworld-controller
spec:
  replicas: 2
  selector:
    app: helloworld
  template:
    metadata:
       labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000


Horizental scale
kubectl scale --replicas=4 -f /root/kubernetes-course/replication-controller/helloworld-repl-controller.yml 
kubectl scale --replicas=4 rc/helloworld-controller
##########################################################################
####################################(Deployments)#########################
##########################################################################
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000

kubectl expose deployment helloworld-deployment --type=NodePort 
kubectl get deployments                           #get information about current deployments
kubectl get rs                                    #get about replica set
kubectl get pods  --show-labels                   #get show labels
kubectl create -f deployment/helloworld.yml --record
kubectl rollout status deploymne/helloworld-deployment  # get deployments status
kubectl set image deployment/helloworld-deployment k8s-demo=k8s-demo:2 
kubectl rollout status deploymne/helloworld-deployment 
kubectl edit deployment/helloworld-deployment  #revisionHistoryLimit: 100
kubectl rollout history deployments/helloworld-deployment
kubectl rollout undo deployments/helloworld-deployment   #rollback to previos version
kubectl rollout undo deployments/helloworld-deployment --to-revision=n 	 #rollback to n version
kubectl expose deployment helloworld-deployment --type=NodePort 
kubectl scale --replicas=4 -f /root/kubernetes-course/replication-controller/helloworld-repl-controller.yml 
kubectl scale --replicas=4 rc/helloworld-controller
 
##########################################################################
####################################(Service)#############################
##########################################################################



ClusterIP : This is the default Service Type, only reachable from within the cluster. Consider this as an internal load balancer.
NodePort : The NodePort opens a static port on each node’s external networking interface. A ClusterIP is also automatically created when we create a NodePort Service. External traffic to the port will be routed to the internal cluster IP. We can use the combination of “NodeIP : NodePort” to call the NodePort Service from outside the cluster.
LoadBalancer : The LoadBalancer Service type creates a cloud provider’s external load balancer. The NodePort and ClusterIP will also be created automatically when we create a LoadBalancer Service. External traffic to the load balancer will be routed to the NodePort which in turn will be routed to internal ClusterIP.

apiVersion: v1
kind: Pod
metadata:
  name: nginx-igap
  labels:
    app: nginx-igap
spec:
  containers:
  - name: nginx-igap
    image: nginx
    ports:
    - name: nginx-port
      containerPort: 80


apiVersion: v1
kind: Service
metadata:
  name: nginx-igap-service
spec:
  ports:
  - port: 80
    targetPort: nginx-port
    protocol: TCP
  selector:
    app: nginx-igap
  type: NodePort
##########################################################################
####################################(LABLE)###################################
##########################################################################
for instance a particular pod can only run on a node labled with "envirement" equals "Development" or "qa"
once nodes are tagged you can use lable selectors to let pods only run on specific nodes

there are 2 steps require to  run a pod on specific set of nodes:
-first you tag the node
-then you add a nodeSelector to your pod configuration

first step add a lable or multiple lables to your nodes:
kubectl lable nodes docker2 hardware=docker22



demo
 apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000
      nodeSelector:
        hardware: docker22


##########################################################################
####################################(HEALTH CHECK)########################
##########################################################################
if your application malfunctions the pod and container can still be running but the application might not work anymore
to detect and resolve problem with your application you can run health checks 
you can run 2 duffrent type of health checks
-running a command in the container periodiclly
-perodic checks on a url(http)

